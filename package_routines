######################################################################
# REFERENCE OF ALWAYS-AVAILABLE SYSTEM COMMANDS
######################################################################
#CMD_AWK="/bin/awk"
#CMD_CAT="/bin/cat"
#CMD_CHMOD="/bin/chmod"
#CMD_CHOWN="/bin/chown"
#CMD_CP="/bin/cp"
#CMD_CUT="/bin/cut"
#CMD_DATE="/bin/date"
#CMD_ECHO="/bin/echo"
#CMD_EXPR="/usr/bin/expr"
#CMD_FIND="/usr/bin/find"
#CMD_GETCFG="/sbin/getcfg"
#CMD_GREP="/bin/grep"
#CMD_GZIP="/bin/gzip"
#CMD_HOSTNAME="/bin/hostname"
#CMD_LN="/bin/ln"
#CMD_LOG_TOOL="/sbin/log_tool"
#CMD_MD5SUM="/bin/md5sum"
#CMD_MKDIR="/bin/mkdir"
#CMD_MV="/bin/mv"
#CMD_RM="/bin/rm"
#CMD_RMDIR="/bin/rmdir"
#CMD_SED="/bin/sed"
#CMD_SETCFG="/sbin/setcfg"
#CMD_SLEEP="/bin/sleep"
#CMD_SORT="/usr/bin/sort"
#CMD_SYNC="/bin/sync"
#CMD_TAR="/bin/tar"
#CMD_TOUCH="/bin/touch"
#CMD_WGET="/usr/bin/wget"
#CMD_WLOG="/sbin/write_log"
#CMD_XARGS="/usr/bin/xargs"
#CMD_7Z="/usr/local/sbin/7z"

######################################################################
# REFERENCE OF IMPORTANT SYSTEM FILES/VARIABLES
######################################################################
#SYS_CONFIG_DIR="/etc/config"
#SYS_INIT_DIR="/etc/init.d"
#SYS_STARTUP_DIR="/etc/rcS.d"
#SYS_SHUTDOWN_DIR="/etc/rcK.d"
#SYS_RSS_IMG_DIR="/home/httpd/RSS/images"
#SYS_QPKG_DATA_FILE_GZIP="./data.tar.gz"
#SYS_QPKG_DATA_FILE_BZIP2="./data.tar.bz2"
#SYS_QPKG_DATA_FILE_7ZIP="./data.tar.7z"
#SYS_QPKG_DATA_CONFIG_FILE="./conf.tar.gz"
#SYS_QPKG_DATA_MD5SUM_FILE="./md5sum"
#SYS_QPKG_DATA_PACKAGES_FILE="./Packages.gz"
#SYS_QPKG_CONFIG_FILE="$SYS_CONFIG_DIR/qpkg.conf"
#SYS_QPKG_CONF_FIELD_QPKGFILE="QPKG_File"
#SYS_QPKG_CONF_FIELD_NAME="Name"
#SYS_QPKG_CONF_FIELD_VERSION="Version"
#SYS_QPKG_CONF_FIELD_ENABLE="Enable"
#SYS_QPKG_CONF_FIELD_DATE="Date"
#SYS_QPKG_CONF_FIELD_SHELL="Shell"
#SYS_QPKG_CONF_FIELD_INSTALL_PATH="Install_Path"
#SYS_QPKG_CONF_FIELD_CONFIG_PATH="Config_Path"
#SYS_QPKG_CONF_FIELD_WEBUI="WebUI"
#SYS_QPKG_CONF_FIELD_WEBPORT="Web_Port"
#SYS_QPKG_CONF_FIELD_SERVICEPORT="Service_Port"
#SYS_QPKG_CONF_FIELD_SERVICE_PIDFILE="Pid_File"
#SYS_QPKG_CONF_FIELD_AUTHOR="Author"
#SYS_QPKG_CONF_FIELD_RC_NUMBER="RC_Number"
#SYS_EXTRACT_DIR="$(pwd)"

######################################################################
# REFERENCE OF AUTO-ASSIGNED MACHINE-DEPENDENT VARIABLES
######################################################################
#SYS_HOSTNAME=$($CMD_HOSTNAME)

## One of: SYS_QPKG_DATA_FILE_GZIP, SYS_QPKG_DATA_FILE_BZIP2 or SYS_QPKG_DATA_FILE_7ZIP.
#SYS_QPKG_DATA_FILE=""

## Destination volume (e.g. "/share/MD0_DATA").
#SYS_QPKG_BASE=""

## Destination path for all QPKG packages ("$SYS_QPKG_BASE/.qpkg").
#SYS_QPKG_INSTALL_PATH=""

## Destination path for this QPKG package ("$SYS_QPKG_INSTALL_PATH/$QPKG_NAME").
#SYS_QPKG_DIR=""

## Should the QPKG be enabled or disabled after the installation/upgrade? By default, 'FALSE' for installation and the previous state for upgrade operation. If 'TRUE' and start fails, the QPKG is disabled.
#SYS_QPKG_SERVICE_ENABLED=""

## Architecture of the device the QPKG is installed on.
#SYS_CPU_ARCH=""

## Name and location of system shares
#SYS_PUBLIC_SHARE=""
#SYS_PUBLIC_PATH=""
#SYS_DOWNLOAD_SHARE=""
#SYS_DOWNLOAD_PATH=""
#SYS_MULTIMEDIA_SHARE=""
#SYS_MULTIMEDIA_PATH=""
#SYS_RECORDINGS_SHARE=""
#SYS_RECORDINGS_PATH=""
#SYS_USB_SHARE=""
#SYS_USB_PATH=""
#SYS_WEB_SHARE=""
#SYS_WEB_PATH=""

## Path to ipkg or opkg package tool if installed.
#CMD_PKG_TOOL=""

######################################################################
# REFERENCE OF OUR VARIABLES
######################################################################

## Entware-ng dependency QPKG name.
ENTWARE_NAME="Entware-ng"

## Installation log file.
QPKG_LOG_FILE="/var/log/coldsweat-install-tmp.log"
QPKG_LOG_FILE_FINAL="/var/log/coldsweat-install.log"

## Coldsweat data folder.
CS_DATA_FOLDER="/etc/coldsweat"

######################################################################
# REFERENCE OF OUR COMMANDS
######################################################################
CMD_OPKG="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/opkg"
CMD_PATCH="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/patch"
CMD_MAKE="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/make"
CMD_LDCONFIG="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/ldconfig"
CMD_PYTHON="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/python"
CMD_EASY_INSTALL="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/easy_install"
CMD_PIP="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/pip"
CMD_UNZIP="$SYS_QPKG_INSTALL_PATH/$ENTWARE_NAME/bin/unzip"

######################################################################
# TIPS & HELPERS
######################################################################
## Useful tips:
# - 'help test' for more information on Shell tests
# - engine ignores any values returned by the principal functions
# - all variables defined in 'qpkg.cfg' are automatically passed
## Useful predefined helper functions:
# - command: log <msg>
#	- outputs <msg> to stdout AND system log
# - command: warn_log <msg>
#	- outputs <msg> to stderr AND system log
# - command: err_log <msg>
#	- outputs <msg> to stderr AND system log
#	- alerts the web interface and prevents the installation/upgrade from proceeding
#	- example: err_log "Data file not found." => "myApp 0.1 installation failed. Data file not found."
# - command: get_share_path <share-name> <variable>
#	- <variable> will now hold real path to the given share (e.g. not '/share/<share-name>')
# - command: add_qpkg_config <config-file> <md5sum>
#	- add a configuration file to '$SYS_QPKG_CONFIG_FILE', if not already present
#	- <md5sum> refers to the file included in the package (should be 0 for dynamically generated files)
# - command: set_qpkg_config <config-file> <md5sum>
#	- update the <md5sum> of an existing configuration file
# - command: extract_data <archive> <directory>
#    - extract the given TAR archive to the given directory ('$SYS_QPKG_DIR' by default)
# - commands: is_equal, is_unequal, is_less_or_equal, is_less, is_greater, is_greater_or_equal
#    - QPKG version comparison - take two arguments (strings) and return 0 if the test is successful

## Usage for the '/sbin/getcfg' command:
# Usage: getcfg section field [ -f profile ] [ -d def_value ] [ -c ] [ -u ]
#	-f profile - Specify the path of the profile
# 	-d def_value - Specify default value to be returned on failure
# 	-c - Section and field names are case sensitive
#	-u - Convert result to upper case

restore_state()
{
	# restore original PATH
	export PATH="$PATH_BCKP"
	
	# before we restore the original IO state, copy the log (it'll get truncated)
	$CMD_CP "$QPKG_LOG_FILE" "$QPKG_LOG_FILE_FINAL"
	
	# and finally, restore the original IO state
	exec &>/dev/stdout
}

my_exit()
{
	# restore the original IO state
	restore_state
	err_log "$1"
}

######################################################################
# OUR PRE-INSTALLATION INITIALIZATION
######################################################################

# NOTES:
# - "$SYS_QPKG_DIR" hasn't been created yet if we're not upgrading

# First entry point.
pkg_init()
{
	# create or truncate the log file
    > "$QPKG_LOG_FILE"
    
    # redirect stdout and stderr of this script to the above log file
    # Note: eventually, restore the original state with 'exec &>/dev/tty'
    exec >> "$QPKG_LOG_FILE"
	exec 2>&1
	
	# time to start logging
	$CMD_ECHO -e "[Initializing...]"
	
	# backup the current PATH (we will likely change it later on)
	export PATH_BCKP="$PATH"
	$CMD_ECHO -e "--- PATH backed up"
}

# Second entry point. Supposed to check requirements here.
pkg_check_requirement()
{
	# the same requirement is specified in 'qpkg.cfg' but it doesn't hurt to really make sure
	if [ -z "$($CMD_GETCFG $ENTWARE_NAME $SYS_QPKG_CONF_FIELD_NAME -f $SYS_QPKG_CONFIG_FILE)" ]; then
		err_log "Entware-ng is not installed. See 'https://forum.qnap.com/viewtopic.php?f=351&t=116737'."
	else
		$CMD_ECHO -e "--- Entware-ng... found"
    fi
}

######################################################################
# OUR INSTALLATION
######################################################################

# NOTES:
# - "$SYS_QPKG_DIR" has just been created if we're not upgrading
# - data has just been extracted from '$SYS_QPKG_DATA_FILE', if specified
# - configuration files have just been handled

# Third entry point.
pkg_pre_install()
{
	$CMD_ECHO -e "\n[Installing basic python dependencies...]"
	
    # install basic python dependencies using Entware (QPKG python is very limited)
    $CMD_OPKG update
    $CMD_OPKG install wget curl
    $CMD_OPKG install python python-setuptools
    $CMD_OPKG --force-overwrite install python-dev
    $CMD_EASY_INSTALL pip
}

# NOTES:
# - shared and platform-dependent files have just been copied to "$SYS_QPKG_DIR"

# Fourth entry point.
pkg_install()
{
	cd "$SYS_QPKG_DIR"

	# for the below installation, we have to temporarily alter the PATH...
	export PATH="/opt/bin:$PATH"
	$CMD_ECHO -e "--- '/opt/bin' prepended to PATH ahead of time"
	
	# GENERAL NOTE TO THE WHOLE INSTALLATION PROCESS
	# It is very straightforward, except that Coldsweat requires the 'readline' python module which
	# is absent from all Python distributions for QNAP that I know of. It can be added manually via
	# 'pip install gnureadline' but that requires either a statically compiled GNU readline library
	# on the system AND respective include headers (absent on QNAP devices), OR a proper compiler.
	# Possible solutions are:
	#
	# 1) Cross-compile GNU readline and include it in the QPKG. Personally, I refuse the hassle of
	# cross-compilation though. Sorry :).
	#
	# 2) Getting a proper compiler on the target device - all that takes is installing 'Entware-ng'
	# on your QNAP. Entware-ng is the most up-to-date package manager for NAS devices and we could
	# have a go with its beta 'gcc' package. Although Entware-ng's Wiki page for 'gcc' says that
	# "static linking is not supported, there are no static libraries", I managed to successfully
	# link and compile the above PIP module to GNU readline static library that I found in QNAP's
	# Qsirch QPKG. God knows what version that is, however, and such a 'random' procedure is highly
	# nasty - we will compile our own version instead.
	# If Entware-ng's 'gcc' is really not capable of producing working static libraries, I could
	# still fork the above PIP module to require shared libraries instead.
	#
	# 3) As a followup to option #2, Entware-ng's 'libreadline' package could be used to skip
	# compiling the library BUT Entware-ng packages do not contain include headers, by design. We
	# can either create them locally (with a compiler) or download them:
	# 	wget -qO- http://pkg.entware.net/binaries/armv7/include/include.tar.gz
	# Notice the 'armv7' in the URL. QPKG installation script would then have to determine the
	# correct architecture from 'uname -a'.
	#
	# Obviously, #2 and #3 are the best. #3 seems convenient and short but still requires a fork
	# of the PIP module. As such, I'm going with the second option.
	# SEE ALSO: https://github.com/Entware-ng/Entware-ng/wiki/Using-gcc-(native-compilation)
	#
	
	# extract Coldsweat ahead of time
	$CMD_TAR xf "lib/coldsweat-0.9.6.tar.gz"
	
	# branch in regard to operation type
    IS_UPGRADE="$($CMD_GETCFG $QPKG_NAME $SYS_QPKG_CONF_FIELD_NAME -f $SYS_QPKG_CONFIG_FILE)"
    if [ -z "$IS_UPGRADE" ]; then
    	# if package is being installed, not upgraded/downgraded...
		# install GNU grep (recent-enough GNU readline requires a better grep than QTS ships with)
		$CMD_ECHO -e "\n[Installing GNU grep...]"
		$CMD_OPKG install gcc busybox ldd make gawk sed
		$CMD_TAR xf "lib/grep-2.26.tar.gz"
		cd "grep-2.26"
		# ./configure --prefix="$(pwd)/install"
		./configure --prefix="/usr/local"
		$CMD_MAKE
		$CMD_MAKE install
		cd ..
		
        # check for existing installation of GNU readline on the system, disregarding Entware
        $CMD_OPKG install ldconfig
        LIB_RL_FOUND="$(ldconfig -p | grep libreadline)"
        LIB_HIST_FOUND="$(ldconfig -p | grep libhistory)"
        if [ -z "$LIB_RL_FOUND" ] || [ -z "$LIB_HIST_FOUND" ]; then
        	$CMD_ECHO -e "\n[Installing GNU readline...]"
        	$CMD_OPKG install patch
			$CMD_TAR xf "lib/readline/readline-6.3.tar.gz"
			cd "readline-6.3"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-001"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-002"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-003"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-004"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-005"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-006"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-007"
			$CMD_PATCH -p0 -t -i "../lib/readline/readline63-008"
			./configure --prefix="/usr/local"
			$CMD_MAKE
			$CMD_LDCONFIG	# sometimes, make install may issue a request to run this
			$CMD_MAKE install
			cd ..
		else
			$CMD_ECHO -e "--- GNU readline... found"
		fi
		
        # install the 'readline' python module for GNU readline
        $CMD_ECHO -e "\n[Installing 'readline' python module...]"
		$CMD_PIP install "gnureadline"
		
		# install Coldsweat dependencies
		$CMD_ECHO -e "\n[Installing Coldsweat dependencies...]"
		$CMD_PIP install -r "coldsweat-0.9.6/requirements.txt"
		
        # cleanup
        $CMD_RM -rf "grep-2.26" "readline-6.3"
    else
	    # if package is being upgraded/downgraded, not installed...
	    # Note: should we need to upgrade GNU readline or GNU grep, a future revision will do that...
	    # TODO: what if the user messes up and (e.g.) removes something important from Entware?
	    # TODO: how to pick up any error codes and explicitly fail so that the installation is not successful when it actually fails?
	    
	    # first install new Coldsweat dependencies
	    $CMD_ECHO -e "\n[Installing Coldsweat dependencies...]"
		$CMD_PIP install -r "coldsweat-0.9.6/requirements.txt"
	    
	    # then upgrade the previous ones
	    $CMD_ECHO -e "\n[Upgrading Coldsweat dependencies...]"
		$CMD_PIP install -r --upgrade "coldsweat-0.9.6/requirements.txt"
		
		# and finally, upgrade the database
		$CMD_ECHO -e "\n[Upgrading Coldsweat database...]"
		$CMD_PYTHON "coldsweat-0.9.6/sweat.py" upgrade
    fi
    
	# always patch Coldsweat to look for the config file in an independent location
	$CMD_ECHO -e "\n[Installing Coldsweat...]"
	$CMD_ECHO -e "--- this section may be empty"
	$CMD_SED -i '' -E "s/config = load_config\(os\.path\.join\(installation_dir, 'etc\/config'\)\)/config = load_config\('\/etc\/coldsweat\/config'\)/g" "coldsweat-0.9.6/coldsweat/__init__.py"
	
	# always replace Coldsweat configuration file
	if [ ! -d "$CS_DATA_FOLDER" ]; then
		$CMD_MKDIR "$CS_DATA_FOLDER"
	fi
	# use external folder so that the config and database survive uninstallation
	$CMD_RM "$CS_DATA_FOLDER/config"
	$CMD_MV "lib/coldsweat-config" "$CS_DATA_FOLDER/config"
	
	# cleanup
	$CMD_RM -rf "lib"
	
	# and finally, we're done...
	$CMD_ECHO -e "\nInstallation finished."
}

# NOTES:
# - obsolete files from the previous installation have just been removed
# - icons have just been copied from QPKG to "/home/httpd/RSS/images/"
# - symbolic links for the service program have just been created in "/etc/init.d", "/etc/rcS.d" and "/etc/rcK.d"
# - the QPKG has just been registered in "/etc/config/qpkg.conf"

pkg_post_install()
{
	restore_state
}

######################################################################
# OUR UN-INSTALLATION
######################################################################

# NOTES:
# - The following functions have a generic implementation included in the engine.
# - Variables must be used as "\$VAR" (otherwise, their values will be replaced when the uninstall script is created).
# - Command substitutions ("$(command)" or "`command`") must be escaped, otherwise they will be executed before the script is created.

# PKG_PRE_REMOVE="
# {
# }"
# PKG_MAIN_REMOVE="
# {
    # remove system-wide configuration file
    # $CMD_RM -f $QPKG_CONFIG
# }"
# PKG_POST_REMOVE="
# {
# }"
